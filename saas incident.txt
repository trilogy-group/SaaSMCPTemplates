Start working:
- Transition the given issue to in progress

Troubleshoot:
- Read and analyze the Jira issue description to understand the AWS service, resource, and nature of the problem. Derive the required action (e.g., reboot, stop, start, describe, diagnose, log check) based on context—not hardcoded logic.
- Use the `aws_cli_pipeline` tool to perform actions. Required fields:
    - `account_id`: extract from the issue
    - `region`: extract from the issue
    - `command`: construct based on the inferred action and AWS resource
- Extract relevant identifiers from the issue such as:
    - instance ID or resource ID
    - service name (e.g., EC2, Lambda, CloudWatch)
    - alarm name or CloudWatch namespace (if applicable)
    - timestamps or state change indicators
- Determine the current health or status of the AWS resource using appropriate AWS CLI describe commands.
    - For EC2: use `describe-instance-status`
    - For alarms: use `describe-alarms`
    - For Lambda: use `get-function` or check CloudWatch logs
- Based on the context and health/status, determine whether any AWS action is needed:
    - Reboot, stop, or start EC2 instances
    - Check logs for Lambda or ECS
    - Fetch alarm state for CloudWatch issues
    - Diagnose using logs from CloudWatch Log Group or Namespace
- If logs or monitoring data are missing, attempt to query using `filter-log-events` under the CloudWatch namespace or known log groups.
- Construct and run minimal AWS CLI commands using `aws_cli_pipeline` with temporary credentials.
- Summarize findings clearly:
    - Commands executed
    - Output from AWS CLI
    - Inferred action and reasoning
    - Root cause (if found)
    - Final status or next recommended step
- Post this summary in the issue as a comment.

Close issue:
- Fill the required fields in the given issue:
    - Runbook Section => customfield_12200
        - Use below payloads for the options:
            - Create New Runbook -> {'id': '10073'} 
            - Update Existing Runbook -> {'id': '18732'}
            - Not Applicable -> {'id': '18733'} ( Use this option if the runbook section is not explicitly mentioned)
- Transition the given issue to Closed

Block issue:
- Add a comment explaining why this issue is being blocked.
- Fill the required field in the given issue:
  - Blocking Reason => customfield_11121
  - Use one of the following values based on the blocker context:
    - Waiting on Customer Support → {'id': '17508'}
    - Waiting on SSE/PCA → {'id': '17509'}
    - Waiting on BU → {'id': '17510'}
    - Waiting on External Provider → {'id': '17511'}
    - Other Priority → {'id': '17714'}
 - If the block is due to another linked Jira issue, set to:
    - Waiting on SSE/PCA → {'id': '17509'}
 - If the blocking reason cannot be determined or is not explicitly mentioned, set to:
    - Other Priority → {'id': '17714'}
- Transition the issue to the Blocked status using the appropriate workflow transition.
- Do not add any comment after transitioning to Blocked status as it will automatically transition the issue from Blocked back to In Queue 

Unblock issue:
- Add a comment explaining why the issue is being unblocked
- Transition the issue status to In Queue.

Escalate to DevOps:
- Add a comment explaining why the issue is being escalated to DevOPs
- For the given issue, set Escalation Level field (customfield_10067) to {'id': '10073'}



